"""Protocol definitions and helpers for PC<->Android communication (Phase 1-4).

This module defines the message formats and utilities for the JSON, line-
delimited protocol used between the PC Hub and Android Spokes.

See:
- docs/4_1_phase.md
- docs/4_4_phase.md

Service Type (mDNS/Zeroconf):
- _gsr-controller._tcp.local.
"""
from __future__ import annotations

from typing import Any, Dict, Tuple
import json
import ast
import time

# Phase 1
QUERY_CMD_ID = 1
COMMAND_QUERY_CAPABILITIES = "query_capabilities"

# Phase 4 commands
COMMAND_START_RECORDING = "start_recording"
COMMAND_STOP_RECORDING = "stop_recording"
COMMAND_FLASH_SYNC = "flash_sync"
COMMAND_TIME_SYNC = "time_sync"
COMMAND_PREVIEW_REQUEST = "preview_request"

# Phase 5 command
COMMAND_TRANSFER_FILES = "transfer_files"


def build_query_capabilities() -> str:
    """Return a JSON line string for the capabilities query.

    The payload matches the Phase 1 spec and ends with a newline suitable
    for line-oriented TCP protocols.
    """
    payload = {"id": QUERY_CMD_ID, "command": COMMAND_QUERY_CAPABILITIES}
    return json.dumps(payload) + "\n"


def build_start_recording(session_id: str, msg_id: int) -> str:
    """Build a start_recording command with a session_id.

    Parameters
    ----------
    session_id: str
        Unique session identifier generated by the PC Hub.
    msg_id: int
        Monotonic message id for ack correlation.
    """
    payload = {"id": msg_id, "command": COMMAND_START_RECORDING, "session_id": session_id}
    return json.dumps(payload) + "\n"


def build_stop_recording(msg_id: int) -> str:
    """Build a stop_recording command."""
    payload = {"id": msg_id, "command": COMMAND_STOP_RECORDING}
    return json.dumps(payload) + "\n"


def build_flash_sync(msg_id: int) -> str:
    """Build a flash_sync command."""
    payload = {"id": msg_id, "command": COMMAND_FLASH_SYNC}
    return json.dumps(payload) + "\n"


def build_time_sync_request(msg_id: int, t0_ns: int | None = None) -> str:
    """Build a time_sync request with PC timestamp t0 in nanoseconds."""
    t0 = int(t0_ns if t0_ns is not None else time.time_ns())
    payload = {"id": msg_id, "command": COMMAND_TIME_SYNC, "t0": t0}
    return json.dumps(payload) + "\n"


def build_transfer_files(host: str, port: int, session_id: str, msg_id: int) -> str:
    """Build a transfer_files command with receiver host/port and session id."""
    payload = {
        "id": msg_id,
        "command": COMMAND_TRANSFER_FILES,
        "host": host,
        "port": int(port),
        "session_id": session_id,
    }
    return json.dumps(payload) + "\n"


def parse_json_line(line: str) -> Dict[str, Any]:
    """Parse a single JSON line into a dictionary.

    Primary parser is strict JSON. If that fails (e.g., tests provide
    Python-literal dicts with True/False), fall back to ast.literal_eval.
    """
    try:
        return json.loads(line)
    except Exception:
        # Safe evaluation of Python literals as a fallback for tests
        obj = ast.literal_eval(line)
        if not isinstance(obj, dict):  # type: ignore[unreachable]
            raise ValueError("Parsed object is not a dict")
        return obj  # type: ignore[return-value]


def compute_time_sync(t0: int, t1: int, t2: int, t3: int) -> Tuple[int, int]:
    """Compute (offset_ns, delay_ns) using NTP-like algorithm.

    offset = ((t1 - t0) + (t2 - t3)) / 2
    delay = (t3 - t0) - (t2 - t1)

    Returns a tuple of integers (offset_ns, delay_ns).
    """
    offset = ((t1 - t0) + (t2 - t3)) // 2
    delay = (t3 - t0) - (t2 - t1)
    return int(offset), int(delay)
